package org.webtree.Base.DAO;

import org.webtree.Base.MVC.BaseModel;
import org.webtree.Base.MVC.BaseModelList;
import org.webtree.Node.Model.NodeModel;
import org.webtree.System.Exception.LoggedError;
import org.webtree.System.WtDb;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;

/**
 * @author lucifer
 *         Date: 28.04.12
 *         Time: 20:21
 */
public class SqlDAO {

	protected final String SQLSTATE_DUPLICATE = "23505";

	protected static HashMap<String, PreparedStatement> statementsMap = new HashMap<String, PreparedStatement>();

	public SqlDAO() {
	}

	protected static Connection getConnect() {
		return WtDb.getConnect();
	}

	/**
	 *
	 * @param statement
	 * @param autoGeneratedKeys a flag indicating whether auto-generated keys
	 *        should be returned; one of
	 *        <code>Statement.RETURN_GENERATED_KEYS</code> or
	 *        <code>Statement.NO_GENERATED_KEYS</code>
	 * @return
	 * @throws SQLException
	 */
	protected static PreparedStatement getStatement(String statement, int autoGeneratedKeys) throws SqlDAOError {
		if (!statementsMap.containsKey(statement)) {
			try {
				statementsMap.put(statement, getConnect().prepareStatement(statement, autoGeneratedKeys));
			} catch (SQLException e) {
				throw new SqlDAOError(e);
			}
		}
		return statementsMap.get(statement);
	}

	protected static PreparedStatement getStatement(String statement) throws SqlDAOError {
		if (!statementsMap.containsKey(statement)) {
			synchronized (statementsMap){
				if (!statementsMap.containsKey(statement)) {
					try {
						statementsMap.put(statement, getConnect().prepareStatement(statement));
					} catch (SQLException e) {
						throw new SqlDAOError(e);
					}
				}
			}
		}
		return statementsMap.get(statement);
	}

	protected String buildUpdateSet(HashMap<String, Object> values) {
		if (values.isEmpty()) {
			throw new SqlDAOError("Empty values given");
		}
		String result = "";
		boolean first = true;
		String statementTemplate = "\"%s\" = ?";
		for (String key : values.keySet()) {
			if (first) {
				first = false;
			} else {
				result += ", ";
			}

			PreparedStatement statement;
			String sql = String.format(statementTemplate, key);
			try {
				statement = getConnect().prepareStatement(sql);
				statement.setString(1, values.get(key).toString());
			} catch (SQLException e) {
				throw new SqlDAOError(e);
			}

			result += statement.toString();
		}
		return result;
	}

	protected void fillModelList(BaseModelList list, PreparedStatement statement) {
		try {
			ResultSet result = statement.executeQuery();
			while (result.next()) {
				list.add(buildModel(result));
			}
		} catch (SQLException e) {
			throw new SqlDAOError(e);
		}
	}

	//TODO: abstract
	protected BaseModel buildModel(ResultSet resultSet) {
		try {
			NodeModel nodeModel = new NodeModel();
			nodeModel.setId(Integer.parseInt(resultSet.getString("nodeId")));
			nodeModel.setOwnerId(resultSet.getInt("ownerId"));
			try {
				nodeModel.setTitle(resultSet.getString("title"));
			} catch (NodeModel.NodeModelError nodeModelError) {
				throw new LoggedError(nodeModelError);
			}
			nodeModel.setRate(resultSet.getInt("rate"));
			try {
				nodeModel.setTitle(resultSet.getString("title"));
			} catch (NodeModel.NodeModelError nodeModelError) {
				throw new LoggedError(nodeModelError);
			}
			return nodeModel;
		} catch (SQLException e) {
			throw new SqlDAOError(e);
		}
	}


	protected int getOffset(int page, int limit) {
		return (page - 1) * limit;
	}

	public static class SqlDAOError extends LoggedError {
		public SqlDAOError(SQLException e) {
			super(e);
		}

		public SqlDAOError(String message) {
			super(message);
		}

		public SqlDAOError(String message, Throwable cause) {
			super(message, cause);
		}

		//		public SqlDAOError() {
//			super();
//		}
	}
}
